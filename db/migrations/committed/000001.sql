--! Previous: -
--! Hash: sha1:4f03b321e8a2e62f259680c6b5225ba35769e95c

drop schema if exists app_public cascade;

alter default privileges revoke all on sequences from public;
alter default privileges revoke all on functions from public;

revoke all on schema public from public;
grant all on schema public to :DATABASE_OWNER;

create schema app_public;
grant usage on schema public, app_public to :DATABASE_VISITOR;

drop schema if exists app_hidden cascade;
create schema app_hidden;
grant usage on schema app_hidden to :DATABASE_VISITOR;
alter default privileges in schema app_hidden grant usage, select on sequences to :DATABASE_VISITOR;

alter default privileges in schema public, app_public, app_hidden grant usage, select on sequences to :DATABASE_VISITOR;
alter default privileges in schema public, app_public, app_hidden grant execute on functions to :DATABASE_VISITOR;

drop schema if exists app_private cascade;
create schema app_private;

set search_path to app_public, app_hidden, app_private, public;

grant all on all tables in schema app_public to :DATABASE_VISITOR;
grant all on all sequences in schema app_public to :DATABASE_VISITOR;

create function app_private.create_code(len int = 6, alpha boolean = false) 
  returns text language plpgsql volatile as
$$
declare
  v_serial text = '';
  v_i int;
  v_chars text = '0123456789';
begin
  if alpha then
    v_chars = v_chars || 'abcdefghijklmnopqrstuvwxyz';
  end if;
  for v_i in 1 .. len loop
      v_serial = v_serial || substr(v_chars, int4(random() * length(v_chars)), 1);
  end loop;
  return lower(v_serial);
end;
$$;

create type app_public.media_type as enum ('video', 'audio');
create type app_public.promo_code_status as enum ('active', 'used', 'canceled');
create type app_public.purchase_status as enum ('pending', 'canceled','paid');
create type app_public.user_role as enum ('member', 'admin', 'editor');
create type app_public.user_status as enum ('active', 'blocked');

create table app_public.users (
  id int generated by default as identity,
  first_name varchar(32),
  last_name varchar(32),
  avatar varchar(255),
  email citext unique,
  facebook_id bigint unique,
  status user_status default 'active',
  password varchar(255),
  role user_role not null default 'member',
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  primary key(id)
);

comment on column app_public.users.id is E'@omit create,update';
comment on column app_public.users.status is E'@omit
0 active, 1 blocked';
comment on column app_public.users."password" is E'@omit update,delete';
comment on column app_public.users."role" is E'@omit create,update';

create function app_public.current_user_id(not_null boolean default false)
    returns integer
    language plpgsql
    stable security definer set search_path to public as
$$
declare
    user_id integer = current_setting('user.id', true)::integer;
begin
    if not_null and user_id is null then
        raise exception 'You need to be logged in';
    end if;
    return user_id;
end;
$$;

create function app_public.current_user(not_null boolean default true)
  returns users
  stable security definer set search_path to app_public
  language sql as
$$
  select * from users where id = current_user_id(not_null);
$$;

create function app_public.current_user_role()
  returns user_role
  stable security definer set search_path to app_public
  language plpgsql as
$$
declare
  v_user users = app_public.current_user();
begin
  return v_user.role;
end;
$$;

create function app_public.change_user_role(user_id int, role user_role)
  returns users
  security definer set search_path to app_public
  language sql as
$$
  update users set role=$2 where id=user_id returning *;
$$;

create function app_public.change_user_status(user_id int, status user_status)
  returns users
  security definer set search_path to app_public
  language sql as
$$
  update users set status=$2 where id=user_id returning *;
$$;

create table app_public.images (
  id int generated by default as identity,
  url varchar(255) not null,
  caption varchar(255),
  description varchar(255),
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  primary key (id)
);

comment on column app_public.images.id is E'@omit create,update';
comment on column app_public.images.caption is E'@localize';
comment on column app_public.images.description is E'@localize';

create table app_public.article_galleries (
  id int generated by default as identity,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  primary key (id)
);

comment on column app_public.article_galleries.id is E'@omit create,update';

create table app_public.articles (
  id int generated by default as identity,
  path varchar(255) not null unique,
  title varchar(255),
  description text,
  content text,
  published boolean not null default false,
  published_at timestamptz,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  author_id integer references app_public.users (id) on delete 
  set 
    null on update cascade,
    updater_id integer references app_public.users (id) on delete 
  set 
    null on update cascade,
    poster_id integer references app_public.images (id) on delete 
  set 
    null on update cascade,
    gallery_id integer references app_public.article_galleries (id) on delete 
  set 
    null on update cascade,
    primary key (id)
);

comment on column app_public.articles.id is E'@omit create,update';
comment on column app_public.articles.path is E'SEO friendly name to use in url';
comment on column app_public.articles.title is E'@localize';
comment on column app_public.articles.description is E'@localize';
comment on column app_public.articles.content is E'@localize';
comment on column app_public.articles.published_at is E'@omit create
This is automatically changed if ''published'' changed, can be manually provided by ''admin''.';

create table app_public.article_gallery_images (
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  gallery_id integer references app_public.article_galleries (id) on delete cascade on update cascade,
  image_id integer references app_public.images (id) on delete cascade on update cascade,
  primary key (gallery_id, image_id)
);


create table app_public.genres (
  id int generated by default as identity,
  name varchar(255) unique,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  primary key (id)
);

comment on column app_public.genres.id is E'@omit create,update';
comment on column app_public.genres.name is E'@localize';

create table app_public.article_genres (
  article_id integer references app_public.articles (id) on delete cascade on update cascade,
  genre_id integer references app_public.genres (id) on delete cascade on update cascade,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  primary key (article_id, genre_id)
);


create table app_public.article_images (
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  article_id integer references app_public.articles (id) on delete cascade on update cascade,
  image_id integer references app_public.images (id) on delete cascade on update cascade,
  primary key (article_id, image_id)
);


create table app_public.tags (
  id int generated by default as identity,
  name varchar(255) unique,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  primary key (id)
);

comment on column app_public.tags.id is E'@omit create,update';
comment on column app_public.tags.name is E'@localize';

create table app_public.article_tags (
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  article_id integer references app_public.articles (id) on delete cascade on update cascade,
  tag_id integer references app_public.tags (id) on delete cascade on update cascade,
  primary key (article_id, tag_id)
);


create table app_public.compositions (
  id int generated by default as identity,
  path varchar(255) unique,
  title varchar(255),
  description varchar(255),
  composing_start timestamptz,
  composing_end timestamptz,
  published boolean not null default false,
  published_at timestamptz,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  primary key (id)
);

comment on column app_public.compositions.id is E'@omit create,update';
comment on column app_public.compositions.path is E'SEO friendly name to use in url';
comment on column app_public.compositions.title is E'@localize';
comment on column app_public.compositions.description is E'@localize';
comment on column app_public.compositions.published_at is E'@omit create
This is automatically changed if ''published'' changed, can be manually provided by ''admin''.';

create table app_public.open_messages (
  id int generated by default as identity,
  name text,
  email citext not null,
  message varchar(255) not null,
  attached_file text,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  primary key (id)
);

comment on table open_messages is E'Open message that anyone can send to support team.';
comment on column open_messages.id is E'@omit create,update';
comment on column open_messages.email is E'@omit update';

alter table open_messages enable row level security;

create policy select_admin on open_messages for select using (current_user_role() = 'admin');
create policy insert_all on open_messages for insert with check (true);

create function app_private.new_open_message()
  returns trigger
  security definer set search_path to app_private
  language plpgsql as
$$
declare
  v_payload json;
begin
  v_payload = json_build_object(
    'user', app_public.current_user(),
    'message', row_to_json(new)
  );
  perform graphile_worker.add_job('sendMessage', v_payload);
  return new;
end;
$$;

create trigger "send_slack_message"
  after insert on app_public.open_messages
  for each row execute procedure new_open_message();

create table app_public.documents (
  id int generated by default as identity,
  name varchar(32),
  content text,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  primary key(id)
);

comment on column app_public.documents.id is E'@omit create,update';
comment on column app_public.documents.content is E'@localize';

create table app_private.email_verifications (
  id int generated by default as identity,
  user_id integer references app_public.users (id) on delete set null on update cascade,
  email citext not null,
  code text not null default create_code(),
  is_verified boolean default false,
  attempts integer not null default 0,
  sib_message_id text,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  primary key (id),
  unique(user_id, email)
);

create type app_public.email_verification_status as enum ('not_verified', 'sent', 'verified');

create function app_public.users_email_verification_status(i_user users)
  returns email_verification_status
  stable security definer set search_path to app_private
  language sql as
$$
  select (
    case 
    when is_verified then 'verified'::app_public.email_verification_status
    when sib_message_id is not null then 'sent'::app_public.email_verification_status
    else 'not_verified'::app_public.email_verification_status
    end
  ) from email_verifications
    where user_id = i_user.id and email = i_user.email;
$$;

create type app_public.send_verification_email_result as (message text, success boolean);

create function app_public.send_verification_email()
  returns send_verification_email_result
  security definer set search_path to app_private, app_public
  language plpgsql as
$$
declare
  v_user users = app_public.current_user();
  v_verification email_verifications;
  v_payload json;
begin
  if v_user.email is null then
    return ('account do not have email', false)::send_verification_email_result;
  end if;

  insert into email_verifications(user_id, email) 
    values(v_user.id, v_user.email)
    on conflict (user_id, email) do update set code = create_code()
    returning * into v_verification;
  
  v_payload = json_build_object(
    'id', v_verification.id,
    'email', v_user.email,
    'code', v_verification.code,
    'lang', current_setting('locale', false)
  );

  perform graphile_worker.add_job('sendVerificationEmail', v_payload);

  return ('code have been sent to email of this accont', true)::send_verification_email_result;
end;
$$;

create type email_verify_result as (message text, success boolean);

create function app_public.verify_email(code text)
  returns email_verify_result
  security definer set search_path to app_private, app_public
  language plpgsql as
$$
declare
  v_user users = app_public.current_user(true);
  v_verification email_verifications;
  v_max_attempts int = 3;
begin
  if v_user.email is null then
    return ('account do not have email', false);
  end if;

  update email_verifications set attempts = attempts + 1
    where email=v_user.email and user_id=v_user.id
    returning * into v_verification;

  if v_verification.attempts > v_max_attempts then
    return ('too many attempts you can try only ' || v_max_attempts || 'times', false);
  end if;

  if v_verification.code = $1 then
    return ('email is verified', true);
  end if;

  return ('invalid verification code', false)::email_verify_result;
end;
$$;

create table app_public.groups (
  id int generated by default as identity,
  founded timestamptz,
  name varchar(255),
  biography text,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  photo_id integer references app_public.images (id) on delete 
  set 
    null on update cascade,
    primary key(id)
);

comment on column app_public.groups.id is E'@omit create,update';
comment on column app_public.groups.name is E'@localize';
comment on column app_public.groups.biography is E'@localize';

create table app_public.group_images (
  group_id integer references app_public.groups (id) on delete cascade on update cascade,
  image_id integer references app_public.images (id) on delete cascade on update cascade,
  primary key (group_id, image_id),
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);


create table app_public.musicians (
  id int generated by default as identity,
  path varchar(255) not null unique,
  birthday date,
  deathday date,
  type varchar(32) not null,
  description text,
  first_name varchar(255),
  last_name varchar(255),
  biography text,
  published boolean not null default false,
  published_at timestamptz,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  photo_id integer references app_public.images (id) on delete 
  set 
    null on update cascade,
  primary key(id)
);

comment on column app_public.musicians.id is E'@omit create,update';
comment on column app_public.musicians.path is E'SEO friendly name to use in url';
comment on column app_public.musicians.description is E'@localize';
comment on column app_public.musicians.first_name is E'@localize';
comment on column app_public.musicians.last_name is E'@localize';
comment on column app_public.musicians.biography is E'@localize';
comment on column app_public.musicians.published_at is E'@omit create
This is automatically changed if ''published'' changed, can be manually provided by ''admin''.';

create table app_public.group_musicians (
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  musician_id integer references app_public.musicians (id) on delete cascade on update cascade,
  group_id integer references app_public.groups (id) on delete cascade on update cascade,
  primary key (musician_id, group_id)
);


create table app_public.playlists (
  id int generated by default as identity,
  is_public boolean default false,
  name varchar(255),
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  owner_id integer references app_public.users (id) on delete 
  set 
    null on update cascade,
    primary key (id)
);

comment on column app_public.playlists.id is E'@omit create,update';
comment on column app_public.playlists.name is E'@localize';

create table app_public.group_playlists (
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  group_id integer references app_public.groups (id) on delete cascade on update cascade,
  playlist_id integer references app_public.playlists (id) on delete cascade on update cascade,
  primary key (group_id, playlist_id)
);


create table app_public.instruments (
  id int generated by default as identity,
  name varchar(255),
  description text,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  primary key(id)
);

comment on column app_public.instruments.id is E'@omit create,update';
comment on column app_public.instruments.name is E'@localize';

create table app_public.languages (
  code varchar(2) not null unique,
  primary key (code)
);

comment on table app_public.languages is E'@omit update,delete';

create table app_public.media (
  id int generated by default as identity,
  url varchar(255) not null,
  media_type app_public.media_type,
  title varchar(255),
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  primary key (id)
);

comment on column app_public.media.id is E'@omit create,update';
comment on column app_public.media.title is E'@localize';

create table app_public.musician_compositions (
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  composition_id integer references app_public.compositions (id) on delete cascade on update cascade,
  musician_id integer references app_public.musicians (id) on delete cascade on update cascade,
  primary key (composition_id, musician_id)
);


create table app_public.musician_genres (
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  musician_id integer references app_public.musicians (id) on delete cascade on update cascade,
  genre_id integer references app_public.genres (id) on delete cascade on update cascade,
  primary key (musician_id, genre_id)
);


create table app_public.musician_images (
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  image_id integer references app_public.images (id) on delete cascade on update cascade,
  musician_id integer references app_public.musicians (id) on delete cascade on update cascade,
  primary key (image_id, musician_id)
);


create table app_public.musician_playlists (
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  musician_id integer references app_public.musicians (id) on delete cascade on update cascade,
  playlist_id integer references app_public.playlists (id) on delete cascade on update cascade,
  primary key (musician_id, playlist_id)
);


create table app_public.professions (
  id int generated by default as identity,
  name varchar(255) unique,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  primary key (id)
);

comment on column app_public.professions.id is E'@omit create,update';
comment on column app_public.professions.name is E'@localize';

create table app_public.musician_professions (
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  musician_id integer references app_public.musicians (id) on delete cascade on update cascade,
  profession_id integer references app_public.professions (id) on delete cascade on update cascade,
  primary key (musician_id, profession_id)
);


create table app_public.musician_tags (
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  musician_id integer references app_public.musicians (id) on delete cascade on update cascade,
  tag_id integer references app_public.tags (id) on delete cascade on update cascade,
  primary key (musician_id, tag_id)
);


create table app_public.page_sections (
  page varchar(255) not null,
  name varchar(255) not null,
  attrs jsonb not null default '{}',
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  primary key (page, name)
);


create table app_public.playlist_media (
  index integer,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  media_id integer references app_public.media (id) on delete cascade on update cascade,
  playlist_id integer references app_public.playlists (id) on delete cascade on update cascade,
  primary key (media_id, playlist_id)
);

comment on column app_public.playlist_media.index is E'Order in playlist';

create table app_public.promo_codes (
  code text unique,
  status promo_code_status not null default 'active',
  percent integer not null default 0,
  expires_at timestamptz,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  primary key (code)
);

comment on table app_public.promo_codes is E'@omit create';
comment on column app_public.promo_codes.code is E'@omit create,update
this also will be used as id';
comment on column app_public.promo_codes.percent is E'discount percent, default is 0';

alter table app_public.promo_codes enable row level security;

create policy select_admin on promo_codes for select using (current_user_role() = 'admin');
create policy update_admin on promo_codes for update using (current_user_role() = 'admin');
create policy insert_admin on promo_codes for insert with check (current_user_role() = 'admin');
create policy delete_admin on promo_codes for delete using (current_user_role() = 'admin');

create table app_public.scores (
  id int generated by default as identity, 
  path varchar(255) not null unique, 
  title varchar(255),
  description varchar(255),
  url varchar(255),
  prices jsonb,
  stamp_right varchar(12), 
  stamp_center varchar(12), 
  published boolean not null default false,
  published_at timestamptz,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  composition_id integer references app_public.compositions (id) on delete set null on update cascade,
  primary key (id)
);

comment on column app_public.scores.id is E'@omit create,update';
comment on column app_public.scores.path is E'SEO friendly name to use in url';
comment on column app_public.scores.title is E'@localize';
comment on column app_public.scores.description is E'@localize';
comment on column app_public.scores.prices is E'amount - currency pairs';
comment on column app_public.scores.stamp_right is E'Right side stamp page selection https://pdfcpu.io/getting_started/page_selection, ex. 1';
comment on column app_public.scores.stamp_center is E'Center side stamp page selection https://pdfcpu.io/getting_started/page_selection, ex. 2-';
comment on column app_public.scores.published_at is E'@omit create
This is automatically changed if ''published'' changed, can be manually provided by ''admin''';

create function app_public.scores_is_purchased(score scores)
  returns boolean language plpgsql
  stable security definer set search_path to app_public as
$$
begin
  return exists(
    select 1 from purchases where user_id=current_user_id() and score_id=score.id and status='paid'
  );
end;
$$;

create table app_public.purchases (
  id int generated by default as identity,
  status purchase_status not null default 'pending',
  promo_code varchar(32),
  currency varchar(6) not null,
  price decimal(12, 2) not null,
  discount_price decimal(12, 2),
  token varchar(36),
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  score_id integer not null references app_public.scores (id) on delete RESTRICT on update cascade,
  user_id integer references app_public.users (id) on delete cascade on update cascade,
  primary key (id)
);

comment on column app_public.purchases.id is E'@omit create,update';
comment on column app_public.purchases.currency is E'@omit create, update
Currency requested fot this purchase';
comment on column app_public.purchases.token is E'@omit
Token to verify purchase request';

create table app_private.reset_passwords (
  id uuid not null default uuid_generate_v4(),
  email text not null,
  attempts integer not null default 0,
  is_expired boolean not null default false,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  primary key (id)
);

create type app_public.forgot_password_result as (message text, success boolean);

create function app_public.forgot_password(email citext)
  returns forgot_password_result
  security definer set search_path to app_private, app_public
  language plpgsql as
$$
#variable_conflict use_column
declare
  v_reset_password reset_passwords;
  v_payload json;
begin
  if not exists(select 1 from users where email = $1) then
    return ('there is no user with that email', false);
  end if;
  insert into reset_passwords(email) values(email) returning * into v_reset_password;
  v_payload = json_build_object(
      'token', v_reset_password.id, 
      'email', v_reset_password.email, 
      'lang', current_setting('locale', false)
    );
  perform graphile_worker.add_job('sendResetLink', v_payload);
  return ('password reset link email have been sent', true)::forget_password_result;
end;
$$;

create type app_public.reset_password_result as (message text, success boolean);

create function app_public.reset_password(token text, password text)
  returns reset_password_result
  security definer set search_path to app_private, app_hidden
  language plpgsql as
$$
-- #variable_conflict use_column
declare
  v_max_old interval = interval '1 hour';
  v_max_attempts int = 3;
  v_reset_password reset_passwords;
begin
  update reset_passwords set attempts = attempts + 1
    where token=$1 returning * into v_reset_password;

  if v_reset_password.created_at + v_max_old > now() then
    return ('token has been expired, you can use it in one hour', false)::reset_password_result;
  end if;
  if v_reset_password.attempts > v_max_attempts then
    return ('too many attempts for this token', false)::reset_password_result;
  end if;

  update users set password = $2 where email = v_reset_password.email;
  return ('password have been changed', true)::reset_password_result;
end;
$$;

create table app_public.score_instruments (
  instrument_id integer references app_public.instruments (id) on delete cascade on update cascade,
  score_id integer references app_public.scores (id) on delete cascade on update cascade,
  primary key (instrument_id, score_id),
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);


create table app_public.sessions (
  sid varchar(255),
  sess jsonb not null,
  expire timestamptz default now(),
  primary key (sid)
);

comment on table app_public.sessions is E'@omit';

create table app_public.article_locales (
  source_id integer not null references app_public.articles (id) on delete cascade on update cascade,
  lang varchar(2) not null references app_public.languages (code),
  title varchar(255),
  description text,
  content text,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  primary key (source_id, lang)
);


create table app_public.composition_locales (
  source_id integer not null references app_public.compositions (id) on delete cascade on update cascade,
  lang varchar(2) not null references app_public.languages (code),
  title varchar(255),
  description varchar(255),
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  primary key (source_id, lang)
);


create table app_public.document_locales (
  source_id integer not null references app_public.documents (id) on delete cascade on update cascade,
  lang varchar(2) not null references app_public.languages (code),
  content text,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  primary key (source_id, lang)
);


create table app_public.genre_locales (
  source_id integer not null references app_public.genres (id) on delete cascade on update cascade,
  lang varchar(2) not null references app_public.languages (code),
  name varchar(255) unique,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  primary key (source_id, lang)
);


create table app_public.group_locales (
  source_id integer not null references app_public.groups (id) on delete cascade on update cascade,
  lang varchar(2) not null references app_public.languages (code),
  name varchar(255),
  biography text,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  primary key (source_id, lang)
);


create table app_public.image_locales (
  source_id integer not null references app_public.images (id) on delete cascade on update cascade,
  lang varchar(2) not null references app_public.languages (code),
  caption varchar(255),
  description varchar(255),
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  primary key (source_id, lang)
);


create table app_public.instrument_locales (
  source_id integer not null references app_public.instruments (id) on delete cascade on update cascade,
  lang varchar(2) not null references app_public.languages (code),
  name varchar(255),
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  primary key (source_id, lang)
);


create table app_public.media_locales (
  source_id integer not null references app_public.media (id) on delete cascade on update cascade,
  lang varchar(2) not null references app_public.languages (code),
  title varchar(255),
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  primary key (source_id, lang)
);


create table app_public.musician_locales (
  source_id integer not null references app_public.musicians (id) on delete cascade on update cascade,
  lang varchar(2) not null references app_public.languages (code),
  description text,
  first_name varchar(255),
  last_name varchar(255),
  biography text,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  primary key (source_id, lang)
);


create table app_public.playlist_locales (
  source_id integer not null references app_public.playlists (id) on delete cascade on update cascade,
  lang varchar(2) not null references app_public.languages (code),
  name varchar(255),
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  primary key (source_id, lang)
);


create table app_public.profession_locales (
  source_id integer not null references app_public.professions (id) on delete cascade on update cascade,
  lang varchar(2) not null references app_public.languages (code),
  name varchar(255) unique,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  primary key (source_id, lang)
);


create table app_public.score_locales (
  source_id integer not null references app_public.scores (id) on delete cascade on update cascade,
  lang varchar(2) not null references app_public.languages (code),
  title varchar(255),
  description varchar(255),
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  primary key (source_id, lang)
);


create table app_public.tag_locales (
  source_id integer not null references app_public.tags (id) on delete cascade on update cascade,
  lang varchar(2) not null references app_public.languages (code),
  name varchar(255) unique,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  primary key (source_id, lang)
);


create function app_public.set_timestamps()
  returns trigger language plpgsql as
$$
declare
    v_now timestamp = now();
begin
    if tg_op = 'INSERT' then
        new.created_at = v_now;
        new.updated_at = v_now;
    else
        new.updated_at = v_now;
    end if;
    return new;
end;
$$;

create function app_public.create_promo_code(
    percent int, status promo_code_status = 'active', expires_at timestamptz = null
  )
  returns promo_codes language plpgsql 
  security definer
  set search_path to app_private, app_public as
$$
declare
  v_code text;
  v_promo_code promo_codes;
begin
  loop
    v_code = create_code(6, false);
    if not exists(select 1 from promo_codes where code=v_code) then
        insert into promo_codes(code, percent, status, expires_at)
          values (v_code, $1, $2, $3) returning * into v_promo_code;
        return v_promo_code;
    end if;
  end loop;
end;
$$;

create function app_public.create_promo_codes(
    count int, percent int, status promo_code_status = 'active', expires_at timestamptz = null
  )
  returns promo_codes[]
  strict security definer set search_path to app_private, app_public
  language plpgsql as
$$
declare
  v_promo_codes promo_codes[] = array[]::promo_codes[];
  v_i int;
begin
  for v_i in 1..count loop
    perform append_array(v_promo_codes, create_promo_code(percent, promo_code_status, expires_at));
  end loop;
  return v_promo_codes;
end;
$$;
